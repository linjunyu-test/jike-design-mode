# 接口授权 -- 需求分析阶段

以一个接口授权的需求，进行业务的分析及代码的开发。



## 接到需求

假设现在正在运行的系统有一个功能，那就是对外提供一些 `api` 接口，供第三方使用。原先这些接口都是完全开放的，只要拿到接口的访问方式就能直接访问到。

运行了一段时间后，发现这种方式实在太不安全了，于是你作为一个开发者接到 boss 的一个需求，那就是要为这个接口增加安全性，不能随随便便都能访问。



## 模糊的需求

很明显，给接口增加安全性这样子一个需求，可能以 boss 的视角看，就是一个比较完整且明确的需求，但是作为开发者而言，这样子的需求是极其模糊的，以什么方式增加安全性？对安全性的要求多高？

其实大**多时候业务需求都不是明确和具体的的，而是很模糊很笼统**，可能只是几段没有归纳总结的文字，也可能只是简单的几句话。所以这个时候，面对这种情况，就**需要将笼统的需求变成具体的需求，具体到足够清晰和可执行**。那么，就需要进行**沟通、挖掘、分析、假设、梳理**，搞清楚需求都有哪些，以及是否要分阶段完成，如果需要的话**哪些是现阶段要完成的，哪些是未来需要完成的，有无时间限制？做到什么程度是否有指标进行衡量？**

当然，一下子可能无法整理出所有的需求，也无法一下子就完成所有需求的分析，很多时候都是边开发边回过头来优化需求。这个时候，可以一步一步来，先满足基本的需求需要，然后再慢慢完善。像接口授权这样子的功能，和业务没有太多的关联，所以可以尽量做得通用一些，但是优先满足系统的业务需求，然后再慢慢做成通用的。



## 需求分析第一阶段 -- 账号密码

*提取需求中的一些名词，然后从现实生活中出发，看看其他的程序、网址甚至是生活场景，考虑他们是如何实现的，是否可以借鉴，或者能够辅助你的思考。*

对于安全，从生活中接触到最广泛的安全策略，就是使用账号密码。那么，顺着这条线，对于需要调用系统接口的第三方，提供给他们账号密码，在调用的时候要求调用方，也就是第三方提供账号密码，假如说是 get 请求，要求他们把账号密码拼接到 `url` 上面。系统接收到接口请求后，解析 `url` 上面的账号密码，然后在系统中认证，如果账号密码存在，那么接口调用成功，否则调用失败。

好，现在已经有一个初步的方案了，至少这个方案实现起来是立即执行的，可立即编码的。根据前面说的，对于这个方案可以先完成，然后再完善。当然，实际上可能在此方案上会有更好的方案，并不需要浪费精力和时间去完成，但是在没有更好的方案之前，或者虽然知道这个方案不太行，但是暂时还不知道怎么优化，那么先动手开发，写写代码，在写代码的过程中不断思考，甚至开发完上线试用，然后通过收集使用者的意见，再进行优化和改进。

下面是这个需求的简单实例图：

![image-20210731000425848](..\img\image-20210731000425848.png)



## 需求分析第二阶段 -- OAuth 授权

在上面的第一阶段分析中，其实很明显就能知道，直接使用账号密码，安全性仍然非常低，因为这就意味着需要在  `url` 上面直接输出账号密码，虽然可以通过对账号密码进行加密的方式增加一些安全性，但是本质上并没有太多的差别，而且这种方式还存在“重放攻击”的危险，也就是说，黑客并不需要知道你的账号密码，只要截取到你这个 `url`，就可以直接使用这个带有账号密码的 `url` 重复请求数据了。

所以说，第一阶段的实现存在两个非常严重的问题：

- `url` 上面明文传输账号密码。
- 容易被黑客重放攻击。

为了解决明文传输账号密码的问题，可以借鉴 OAuth 的授权方式。

首先需要有一套生成 token 的公共算法来生成 token ，然后将算法提供给调用方，并提供给调用方一个 `AppId` 和与之对应的 `Secret（密钥）`。调用方在发起接口请求的时候，将要请求的 `Api`、`AppId` 和 `Secret` 通过提供的算法生成 `token`，然后将 `token`、`AppId` 拼接到 `url` 上面，发送到服务端。在服务端，也就是在我们的系统上，需要做以下几件事情：

1. 解析 `url` 上面的 `AppId` 和 `token`，以及请求的 `api`。
2. 判断 `AppId` 是否存在，不存在，授权不通过。存在则进入下一步。
3. 在系统中找到 `AppId` 对应的 `Secret`。
4. 将 `AppId`、`Secret` 和 `api` 通过算法生成一个 token。
5. 将生成的 `token` 和 调用方传过来的 `token` 进行比较，如果一致，授权成功，否则失败。 

到这里，我们已经解决了第一阶段中暴露账号密码的问题了。下面为这一阶段简单的示意图：

![image-20210731002046769](..\img\image-20210731002046769.png)



## 需求分析第三阶段 -- OAuth 授权增加时间戳

仔细分析就会发现，第二阶段对比第一阶段已经好了很多，但是第一阶段的重放问题还是没有解决，那这个问题该怎么处理呢？

其实分析到这里，有时候就会陷入瓶颈，因为重放攻击不是一个好解决的问题，为了确保一定是调用方调用的，常常会采用的方式是增加验证码，甚至每次调用都需要手机号进行验证，但是对于这种借口调用，不宜做到非常严格，这样子反而增加了调用的难度和提升了调用的复杂性。

那么，其实可以不完全解决这个问题，只要我们规定，在某个范围内是安全的就行。那么这个范围是什么呢？答案是时间，通过在 `url` 上面增加时间戳来解决这个问题。

在第二阶段的基础上，每次发送请求时，获取当前的时间戳，将这个时间戳加入到 token 的生成中，并且将时间戳拼接到 `url` 上面。服务端接受到请求后，首先验证一下这个时间戳是否在某个区间内，例如设定是一分钟，那么这个时间戳是否已经过了一分钟，如果过了，那么授权失败。这样子，增加了一个时间戳，就能将重放攻击限制在一个固定的时间窗口内，过了这个时间窗口，例如过了一分钟，那么授权就会失效。

增加了时间戳后，服务需要做的事情：

1. 解析 `url` 上面的 `AppId` 、时间戳 和 `token`，以及请求的 `api`。
2. 先判断这个时间戳是否过了时间窗口，例如和系统的时间相比，是否过了一分钟，如果是，授权不通过。
3. 判断 `AppId` 是否存在，不存在，授权不通过。存在则进入下一步。
4. 在系统中找到 `AppId` 对应的 `Secret`。
5. 将 `AppId`、`Secret` 、时间戳 和 `api` 通过算法生成一个 token。
6. 将生成的 `token` 和 调用方传过来的 `token` 进行比较，如果一致，授权成功，否则失败。

可以看到，其实只是对第二阶段进行了一些小调整。对应的示意图如下图所示：

![image-20210731004001491](..\img\image-20210731004001491.png)



## 完成需求分析

至此，需求分析部分已经完成了。通过一个一个阶段的完善，从一开始模糊、不明确的需求，到现在比较明确且完善的需求，已经是可以立即编码执行的了。所以，作为一个程序员，不应该只顾需求的完成和落地，对于需求的分析和完善同样是很重要的，需求是否清晰、完善和可执行完全决定了了后面编码过程中，代码是否写的通畅已经可用。

需求的分析就是一个不断迭代的过程，没有什么需求是一蹴而就，优秀的框架也都是一点一点积累起来的，不要试图给出一个完美的方法，先从一个满足当前需求的最小实现出发，也许它比较粗糙和简陋，但是后面慢慢的优化就能够使得整个需求是可实现的，且能够实现的很好。